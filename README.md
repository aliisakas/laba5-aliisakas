# Лабораторная №5. Многопоточность 

## Что было сделано
- **Последовательное размытие**: проход по каждому пикселю, усреднение цвета в квадрате 5×5.  
- **Параллельное размытие (std::thread)**: разбили картинку на горизонтальные полосы, каждый поток обрабатывает свою.
- **Размытие с помощью OpenMP**: Обход строк директивой `#pragma omp parallel for`.  
- **Счётчик**: сравнение двух способов защиты общего счётчика при 8 потоках — через `std::mutex` и `std::atomic<int>`.

## Результаты 

| Метод                     | Время, с       |
|---------------------------|----------------|
| Последовательное размытие |   0.0483866    |
| Параллельное размытие     |   0.0232021    |
| OpenMP размытие           |   0.0184879    |
| Счётчик + mutex           |   0.0023896    |
| Счётчик + atomic          |   0.0006843    |

> **Вывод**: Параллельное размытие выполняется быстрее последовательного, а атомарные операции выигрывают у мьютексов по времени из-за меньших накладных расходов.

## Почему это работает
Многопоточность позволяет задействовать сразу несколько ядер процессора, каждый поток делает свою часть работы.

## Синхронизация и её подводные камни
- **Data race**: без защиты потоки могут одновременно читать и писать в одну переменную, что повлияет на результат.
- **`std::mutex`**: блокируем самые критичные части кода, но при частых блокировках потоки ждут и тратят много времени.
- **`std::atomic<int>`**: эффективно для простых операций, потому что аппаратно гарантирует атомарность.
